def solution(cookie):
    answer = -1
    maxnum = 0
    if len(cookie) < 2 :
        return False
    if len(cookie) == 2 :
        if cookie[0] == cookie[1]:
            return cookie[0]
        else:
            return False
    for i in range(len(cookie)-1):
        frontsum = cookie[i]
        indexOfFrontSum = i 
        backsum = cookie[i+1]
        indexOfBackSum = i+1
        
        while True:
            if frontsum == backsum :
                maxnum = max(frontsum, maxnum)
                
            if indexOfFrontSum > 0 and frontsum <= backsum :
                indexOfFrontSum -= 1
                frontsum += cookie[indexOfFrontSum]
                
            elif indexOfBackSum < len(cookie)-1 and frontsum >= backsum:
                indexOfBackSum += 1
                backsum += cookie[indexOfBackSum]
                
            else:
                break
                
    answer = maxnum
    return maxnum
    
    역시 내가 풀지 못했다........OTL...
    처음에 떠올린건 stack이었지만 맞지 않는 방법이었다.
    코드를 찾아보던 중에 dp 라는 단어가 나와서 Dynamic Programming(동적프로그래밍) 이라는걸 공부하게 됐다.
    *동적프로그래밍이란 해결 하려는 문제를 작은 단위로 쪼갠 뒤 그 쪼개진 부분문제들의 답을 이용해 원 문제의 답을 구하는 방식이다.
    최적화된 답을 찾을 수 있다.*
    
    임의의 배열을 만들고 코드 한 줄 한 줄 따라가면서 세번정도 해보니
    이 코드가 옳다는 것은 이해를 했는데 
    이 코드의 while문이 어떤식으로 추론될수(?) 있었는지 그부분이 신기하고 가늠이 안됐다. 
    
   
    
