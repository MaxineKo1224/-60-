def solution(cookie):
    answer = -1
    maxnum = 0
    if len(cookie) < 2 :
        return False
    if len(cookie) == 2 :
        if cookie[0] == cookie[1]:
            return cookie[0]
        else:
            return False
    for i in range(len(cookie)-1):
        fsum = cookie[i]
        findex = i 
        bsum = cookie[i+1]
        bindex = i+1
        
        while True:
            if fsum == bsum :
                maxnum = max(fsum, maxnum)
                
            if findex > 0 and fsum <= bsum :
                findex -= 1
                fsum += cookie[findex]
                
            elif bindex < len(cookie)-1 and fsum >= bsum:
                bindex += 1
                bsum += cookie[bindex]
                
            else:
                break
                
    answer = maxnum
    return maxnum
    
    역시 내가 풀지 못했다........OTL...
    처음에 떠올린건 stack이었지만 맞지 않는 방법이었다.
    코드를 찾아보던 중에 dp 라는 단어가 나와서 Dynamic Programming(동적프로그래밍) 이라는걸 공부하게 됐다.
    *동적프로그래밍이란 해결 하려는 문제를 작은 단위로 쪼갠 뒤 그 쪼개진 부분문제들의 답을 이용해 원 문제의 답을 구하는 방식이다.
    최적화된 답을 찾을 수 있다.*
    
    임의의 배열을 만들고 코드 한 줄 한 줄 따라가면서 세번정도 해보니
    이 코드가 옳다는 것은 이해를 했는데 
    이 코드의 while문이 어떤식으로 추론될수(?) 있었는지 그부분이 신기하고 가늠이 안됐다. 
    
   
    
